# mtrpz lab 04: Url shortener
## Контекст та область застосування

***Автори***:

***Платунов Юрій IM-33*** Backend Developer / Team Lead
Відповідає за архітектуру сервісу, реалізацію бізнес-логіки, інтеграцію з базою даних та основні API.

***Скрипник Михайло IM-33*** — Backend Developer
Відповідає за розробку та тестування окремих підсистем (наприклад, авторизації та аналітики), допомогу з розробкою HTTP-інтерфейсу, написання unit-тестів.

**Формат співпраці**: Ми працюємо як команда з двох бекенд-розробників, використовуючи Git для спільної розробки, code-review та ведення історії змін. Розробили два мікросервіси різними мовами програмування для демонстрації полі-мовної архітектури.

### Мета проєкту
Освоїти спільну роботу з Git, створити невеликий, але корисний pet-проект з реального життя, попрактикуватися у створенні повноцінного backend-сервісу з роботою з базою даних та інтеграцією кількох підсистем. **Додатково демонструємо можливості мікросервісної архітектури з різними технологічними стеками.**

### Проблема

Довгі URL-адреси незручні для поширення в соціальних мережах, SMS, друкованих матеріалах та інших каналах комунікації. Користувачам потрібен сервіс, який може створювати короткі, зручні для запам'ятовування посилання та надавати детальну аналітику переходів.

## Цілі
-  Надати можливість користувачам скорочувати довгі URL-адреси до коротких посилань. 
- Забезпечити перенаправлення з короткого посилання на оригінальний URL. 
- Давати прозору статистику по скороченому посиланню
- Створити зручний REST API для роботи з сервісом (створення, перегляд, видалення посилань).
- **Продемонструвати можливості полі-мовної мікросервісної архітектури**

**Проект створюється не для:**
- Підтримки кастомних доменів або індивідуального налаштування вигляду короткого посилання. 
- Впровадження розширеної аналітики (геолокація, унікальні користувачі, джерела переходів тощо). 
- Мобільні додатки (тільки веб-інтерфейс)
- Персоналізовані короткі посилання (тільки випадкова генерація)

## Високорівнева архітектура

Система використовує **мікросервісну архітектуру з двома незалежними сервісами**, написаними різними мовами програмування:

### Мікросервіси

#### 1. URL Shortener Service (Kotlin/Spring Boot)
**Технології:** Kotlin, Spring Boot, PostgreSQL, JPA/Hibernate
**Відповідальність:**
- Створення коротких посилань
- Перенаправлення користувачів
- Управління посиланнями (CRUD операції)
- Базова статистика кліків

#### 2. Analytics Service (Python/FastAPI)
**Технології:** Python, FastAPI, PostgreSQL (shared database), asyncpg
**Відповідальність:**
- Розширена аналітика та звітність
- Веб-дашборд для моніторингу
- Агреговані статистики по доменах
- Візуалізація даних

### Обгрунтування полі-мовної архітектури

**Чому два різних стеки:**

1. **Демонстрація технічного різноманіття**: Показуємо, як різні команди можуть використовувати знайомі їм технології
2. **Оптимізація під завдання**:
   - Kotlin/Spring Boot - чудово підходить для CRUD операцій та бізнес-логіки
   - Python/FastAPI - ідеальний для аналітики, візуалізації та швидкого прототипування дашбордів
3. **Реальний світ**: У великих компаніях різні команди часто використовують різні стеки залежно від експертизи та вимог

**Переваги полі-мовного підходу:**
- Використання найкращих інструментів для конкретних завдань
- Можливість залучення спеціалістів з різним досвідом
- Незалежне масштабування та деплой сервісів
- Технологічна гнучкість

**Недоліки та виклики:**
- Складність інфраструктури
- Необхідність підтримки різних технологічних стеків
- Потенційні проблеми з консистентністю даних
- Більша складність моніторингу та дебагінгу

### Технологічний стек

#### Core URL Shortener Service
- **Backend**: Kotlin, Spring Boot 3.x
- **База даних**: PostgreSQL
- **ORM**: JPA/Hibernate
- **Build tool**: Gradle
- **Контейнеризація**: Docker

#### Analytics Service  
- **Backend**: Python 3.11, FastAPI
- **База даних**: PostgreSQL (shared with main service)
- **Async driver**: asyncpg
- **Templates**: Jinja2
- **Контейнеризація**: Docker

#### Shared Infrastructure
- **Database**: PostgreSQL (спільна БД для обох сервісів)
- **Containerization**: Docker & Docker Compose
- **Reverse Proxy**: Nginx (опціонально)

### Взаємодія між сервісами

**Database Sharing Pattern:**
- Обидва сервіси використовують одну PostgreSQL базу даних
- URL Shortener Service - пише основні дані
- Analytics Service - читає дані для аналітики
- Уникаємо складності міжсервісної комунікації для MVP

**Альтернативні патерни для production:**
- Event-driven architecture з Kafka/RabbitMQ
- API-based communication між сервісами
- CQRS з окремими read/write базами

## Детальний опис сервісів

### URL Shortener Service (Kotlin)

**Архітектурні принципи:**
- Clean Architecture з розділенням на layers
- Dependency Injection через Spring
- Repository Pattern для data access
- DTO pattern для API контрактів

#### API Schema

| Method | Path                | Request Body                  | Response Body                                        | Description                           |
| ------ | ------------------- | ----------------------------- | ---------------------------------------------------- | ------------------------------------- |
| POST   | `/links`            | `{ "url": "<original_url>" }` | `{ "shortCode": "<code>", "url": "<short_url>", ... }` | Створення нового короткого посилання  |
| GET    | `/{code}`           | —                             | 302 Redirect to `<original_url>`                     | Перенаправлення за коротким кодом     |
| GET    | `/links/{code}`     | —                             | `{ "shortCode": "<code>", "url": "<original_url>" }` | Отримання деталей короткого посилання |
| GET    | `/links/{code}/stats` | —                           | `{ "clicks": <number>, "uniqueVisitors": <number>, ... }` | Отримання статистики переходів        |
| DELETE | `/links/{code}`     | —                             | 204 No Content                                       | Видалення короткого посилання         |


- `LinkController` - REST API endpoints
- `LinkService` - бізнес-логіка
- `LinkRepository` - data access layer
- `Link` entity - JPA entity з оптимістичними блокуваннями
- `ShortCodeGenerator` - генерація унікальних кодів

### Analytics Service (Python)

**Архітектурні принципи:**
- Async/await для high-performance database access
- Connection pooling для оптимізації БД з'єднань
- Jinja2 templates для server-side rendering
- RESTful API + Web Dashboard

#### Веб-дашборд функціональність:
- Загальна статистика (кількість посилань, кліки)
- Графіки створення посилань за днями
- Топ-домени за кількістю посилань
- Таблиця останніх посилань з фільтрацією

#### API Endpoints:
- `GET /` - головна сторінка дашборду
- `GET /api/analytics/summary` - загальна статистика
- `GET /api/analytics/links-by-days` - дані для графіків
- `GET /api/analytics/top-domains` - топ домени
- `GET /api/analytics/recent-links` - останні посилання

## Застосування в реальному світі

### Чому така архітектура корисна в production:

1. **Різні команди, різні експертизи:**
   - Backend команда працює з Kotlin/Spring Boot
   - Data/Analytics команда використовує Python для швидкого прототипування

2. **Незалежне масштабування:**
   - URL shortening - high throughput, низька латентність
   - Analytics - менше навантаження, але складні запити

3. **Technology evolution:**
   - Можна оновлювати сервіси незалежно
   - Легше експериментувати з новими технологіями

### Реальні приклади використання:

**Netflix**: Використовує Java для core services, Python для ML та analytics
**Uber**: Go для high-performance services, Python для data science
**Spotify**: Java/Scala для backend, Python для рекомендаційних систем

### Висновки для реальних проектів:

1. **Polyglot архітектура** дозволяє використовувати найкращі інструменти для кожного завдання
2. **Мікросервіси** забезпечують технологічну незалежність команд
3. **Shared database** може бути прийнятним компромісом для MVP, але потребує еволюції в production
4. **Важливість DevOps**: полі-мовна архітектура потребує надійної CI/CD pipeline

## Альтернативи

Перед вибором мікросервісної архітектури ми розглянули кілька варіантів реалізації:

| #   | Варіант                                           | Переваги                                                                                              | Недоліки / компроміси                                                                                                                                | Чому відхилено/обрано                                                                                                      |
| --- | ------------------------------------------------- | ----------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------- |
| 1   | Моноліт (одна мова)                               | Найпростіший деплой, єдиний стек, простіше дебагити | Складно демонструвати різні технології, менше можливостей для навчання | Відхилено: хотіли показати мікросервісний підхід |
| 2   | Мікросервіси + Event-driven (Kafka)              | Повна ізоляція сервісів, eventual consistency, production-ready | Висока складність, overhead для простого проекту, складно налаштувати локально | Відхилено: занадто складно для навчального проекту |
| 3   | **Мікросервіси + Shared Database (ОБРАНО)**      | Демонструє полі-мовний підхід, простіше за event-driven, реалістично для MVP | Потенційні проблеми з data consistency, coupling через БД | **Обрано**: оптимальний баланс між складністю та навчальною цінністю |
| 4   | Serverless (AWS Lambda)                           | Автоскейлінг, pay-per-use, мінімум DevOps | Vendor lock-in, холодні старти, складність локальної розробки | Відхилено: хотіли показати традиційні мікросервіси |

### Обрана архітектура: Мікросервіси з полі-мовним підходом

**Переваги**:
- Демонструє реальні підходи в індустрії
- Дозволяє використовувати сильні сторони різних технологій
- Навчальна цінність роботи з різними стеками
- Підготовка до роботи в великих командах

**Недоліки**:
- Вища складність інфраструктури
- Потреба підтримувати два різних стеки
- Потенційні проблеми з консистентністю даних

## Діаграма архітектури

```
┌─────────────────┐    ┌─────────────────┐
│   Web Browser   │    │   Analytics     │
│                 │    │   Dashboard     │
└─────────────────┘    └─────────────────┘
         │                       │
         │ HTTP                  │ HTTP
         ▼                       ▼
┌─────────────────┐    ┌─────────────────┐
│ URL Shortener   │    │   Analytics     │
│   Service       │    │    Service      │
│ (Kotlin/Spring) │    │ (Python/FastAPI)│
│                 │    │                 │
│ Port: 8080      │    │ Port: 8001      │
└─────────────────┘    └─────────────────┘
         │                       │
         │ JDBC                  │ asyncpg
         └───────────┬───────────┘
                     ▼
           ┌─────────────────┐
           │   PostgreSQL    │
           │    Database     │
           │                 │
           │ - links table   │
           │ - statistics    │
           └─────────────────┘
```

## Deployment Strategy

**Development Environment:**
```bash
# Запуск через Docker Compose
docker-compose up -d

# URL Shortener: http://localhost:8080
# Analytics Dashboard: http://localhost:8001
# PostgreSQL: localhost:5432
```

**Production Considerations:**
- Kubernetes для оркестрації
- Separate databases для кожного сервісу
- API Gateway для routing
- Service mesh для міжсервісної комунікації
- Distributed tracing для моніторингу